export const EVENT_MEANINGS: Record<string, string> = {
  queue_transition: 'Product changed queue state (pending/running/complete/exhausted).',
  run_started: 'Pipeline run started for the selected product.',
  helper_files_context_loaded: 'Helper files were loaded and matched against the product identity.',
  helper_supportive_fill_applied: 'Known supportive helper values were injected for missing fields.',
  discovery_results_reranked: 'Search/discovery results were reranked for best candidates.',
  source_discovery_only: 'Source was discovered but not fetched (planning/discovery step only).',
  source_fetch_started: 'A source URL fetch has started.',
  fetcher_fallback_enabled: 'Primary fetcher failed and fallback fetch mode was enabled.',
  fetcher_start_failed: 'Fetcher startup failed for this URL/source; fallback or skip logic may follow.',
  source_processed: 'A fetched source was parsed and candidate fields were extracted.',
  fields_filled_from_source: 'Fields were filled from the current source URL.',
  field_conflict_detected: 'A field-level conflict was detected between competing values.',
  source_fetch_failed: 'A fetch failed (timeout, blocked, network, parser, etc).',
  fetch_trace_written: 'A runtime fetch trace blob was written.',
  artifact_written: 'A runtime artifact preview was written.',
  discovery_serp_written: 'SERP trace payload was written for a query.',
  discovery_urls_selected: 'Selected URLs from search reranking were written.',
  planner_queue_snapshot_written: 'Planner/frontier queue snapshot was written.',
  indexing_resume_loaded: 'Resume queue loaded from previous run and seeded into planner.',
  indexing_resume_expired: 'Resume state expired by policy window and was ignored for this run.',
  indexing_resume_start_over: 'Resume state intentionally ignored (fresh start mode).',
  indexing_resume_written: 'Resume queue state was persisted for future runs.',
  llm_retry_source_queued: 'Source URL was queued for LLM retry in a later run.',
  url_cooldown_applied: 'A URL was skipped due to cooldown/dead-pattern memory.',
  llm_call_started: 'LLM call started (plan/extract/validate/summary).',
  llm_route_selected: 'LLM route chosen for this reason/role (provider/model/base URL).',
  llm_route_fallback: 'Primary route failed; fallback provider/model/base URL was used.',
  llm_call_usage: 'LLM token/cost usage was recorded.',
  llm_call_completed: 'LLM call returned successfully.',
  structured_output_shape_mismatch: 'LLM returned JSON that parsed but failed expected schema shape checks.',
  structured_output_fallback_used: 'LLM call retried without strict json_schema response format.',
  llm_trace_written: 'A runtime LLM trace blob was written.',
  llm_trace_write_failed: 'LLM trace artifact could not be written to disk.',
  llm_call_failed: 'LLM call failed for the configured provider.',
  llm_provider_circuit_open: 'LLM provider circuit breaker is open due to repeated failures.',
  llm_discovery_planner_failed: 'LLM discovery planner failed; deterministic fallback used.',
  llm_extract_failed: 'LLM extraction failed; deterministic extraction still continues.',
  llm_extract_skipped_budget: 'LLM extraction skipped because the current budget/call limit was reached.',
  llm_extract_skipped_source: 'LLM extraction skipped for non-extractable source.',
  llm_summary_failed: 'LLM summary writing failed; pipeline summary fallback used.',
  field_decision: 'Final per-field decision accepted/rejected/unknown.',
  round_completed: 'A run round ended.',
  run_completed: 'Run finished and outputs were written.',
  max_run_seconds_reached: 'Run hit max runtime guard and stopped early.',
};

export const PIPELINE_STAGE_DEFS = [
  { id: 'queued', label: 'Queued', events: new Set(['queue_transition', 'run_started']) },
  { id: 'helper', label: 'Helper Matched', events: new Set(['helper_files_context_loaded']) },
  { id: 'discover', label: 'Discovery Planned', events: new Set(['discovery_results_reranked', 'source_discovery_only']) },
  { id: 'fetch', label: 'Sources Fetching', events: new Set(['source_fetch_started']) },
  { id: 'extract', label: 'Extraction', events: new Set(['source_processed', 'field_decision']) },
  { id: 'llm', label: 'LLM Reasoning', events: new Set(['llm_call_started', 'llm_call_completed', 'llm_call_usage']) },
  { id: 'round', label: 'Round Complete', events: new Set(['round_completed']) },
  { id: 'complete', label: 'Run Complete', events: new Set(['run_completed']) },
] as const;

export const UNKNOWN_VALUES = new Set(['', 'unk', 'unknown', 'na', 'n/a', 'none', 'null']);
